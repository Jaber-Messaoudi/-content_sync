<?php

/**
 * @file
 * Contains content_sync.module..
 */

use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_help().
 */
function content_sync_help($route_name, RouteMatchInterface $route_match) {
  if ($route_name === "help.page.content_sync") {
    $output = '<p>' . t('Tool for syncing entities.') . '</p>';
    return $output;
  }
}

/**
 * Queries entities by type ID and exports them into specified module folder.
 *
 * @param string $entity_type_id
 *    Entity machine name.
 * @param string $module_name
 *    Name of the module in which entities will be exported.
 */
function _content_sync_export(
  $entity_type_id,
  $module_name
) {
  $folder = drupal_get_path('module', $module_name);
  $query  = \Drupal::entityQuery($entity_type_id);
  $result = $query->execute();

  foreach ($result as $entity_id) {
    _content_sync_export_entity_with_references($entity_id, $entity_type_id,
      $folder);
  }
}

/**
 * Export Taxonomy terms.
 *
 * @param mixed $vid
 *    Vocabulary ID.
 * @param string $module_name
 *    Name of the module in which entities will be exported.
 */
function _content_sync_export_taxonomy_terms(
  $vid,
  $module_name
) {
  $entity_type_id = 'taxonomy_term';
  $folder         = drupal_get_path('module', $module_name);
  $query          = \Drupal::entityQuery($entity_type_id)
    ->condition('vid', $vid);
  $result         = $query->execute();

  foreach ($result as $entity_id) {
    _content_sync_export_entity_with_references($entity_id, $entity_type_id,
      $folder);
  }
}

/**
 * Returns entities ids byt passed entity_type_id.
 *
 * @param mixed $entity_type_id
 *    Entity Type machine name.
 *
 * @return array|int
 *    An array of entities ids.
 */
function _content_sync_get_entities_ids_by_type_id($entity_type_id) {
  $query  = \Drupal::entityQuery($entity_type_id);
  $result = $query->execute();

  return $result;
}

/**
 * Export menu items by menu machine name.
 *
 * @param string $menu_name
 *    Menu machine name.
 * @param string $module_name
 *    Name of the module from which entities will be exported.
 */
function _content_sync_export_menu_items($menu_name, $module_name) {
  $folder         = drupal_get_path('module', $module_name);
  $entity_type_id = 'menu_link_content';
  $query          = \Drupal::entityQuery('menu_link_content')
    ->condition('menu_name', $menu_name);
  $result         = $query->execute();

  foreach ($result as $menu_link_content_id) {
    _content_sync_export_entity_with_references($menu_link_content_id,
      $entity_type_id, $folder);
  }
}

/**
 * Export entities with references.
 *
 * @param string $entity_content_id
 *    Entity Content ID.
 * @param string $entity_type_id
 *    Entity Type ID.
 * @param string $folder
 *    Folder path where exported JSON will be generated.
 */
function _content_sync_export_entity_with_references(
  $entity_content_id,
  $entity_type_id,
  $folder
) {
  /* @var \Drupal\default_content\DefaultContentManagerInterface $manager */
  $manager = \Drupal::service('default_content.manager');

  $serialized_by_type = $manager->exportContentWithReferences($entity_type_id,
    $entity_content_id);
  foreach ($serialized_by_type as $entity_type => $serialized_entities) {
    // Ensure that the folder per entity type exists.
    $entity_type_folder = "$folder/content/$entity_type";
    file_prepare_directory($entity_type_folder, FILE_CREATE_DIRECTORY);
    foreach ($serialized_entities as $entity_id => $serialized_entity) {
      file_put_contents($entity_type_folder . '/' . $entity_id . '.json',
        $serialized_entity);
    }
  }
}

/**
 * Deletes menu links.
 *
 * @param mixed $menu_name
 *    Machine name of menu.
 */
function _content_sync_menu_clear($menu_name) {
  $query  = \Drupal::entityQuery('menu_link_content')
    ->condition('menu_name', $menu_name)
    ->sort('id', 'ASC');
  $result = $query->execute();

  if (!empty($result)) {
    $entities           = \Drupal::entityManager()
      ->getStorage('menu_link_content')
      ->loadMultiple(array_values($result));
    $entities_to_delete = array();
    foreach ($entities as $entity) {
      $entities_to_delete[$entity->id()] = $entity;
    }

    \Drupal::entityTypeManager()
      ->getStorage('menu_link_content')
      ->delete($entities_to_delete);
  }
}

/**
 * Deletes taxonomy terms links.
 *
 * @param mixed $vid
 *    Vocabulary id.
 */
function _content_sync_vocabulary_clear($vid) {
  $query  = \Drupal::entityQuery('taxonomy_term')->condition('vid', $vid);
  $result = $query->execute();

  if (!empty($result)) {
    $entities           = \Drupal::entityTypeManager()
      ->getStorage('taxonomy_term')
      ->loadMultiple(array_values($result));
    $entities_to_delete = array();
    foreach ($entities as $entity) {
      $entities_to_delete[$entity->id()] = $entity;
    }

    \Drupal::entityTypeManager()
      ->getStorage('taxonomy_term')
      ->delete($entities_to_delete);
  }
}

/**
 * Import entities from module.
 *
 * @param array $options
 *    Array of options.
 *
 * @return int
 *    number of entities created.
 */
function _content_sync_import($options) {
  if (!\Drupal::isConfigSyncing()) {
    $created = \Drupal::service('default_content.manager')
      ->importContent($options);
    return count($created);
  }
}
